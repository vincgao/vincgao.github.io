<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Android Layout绘制 · Vinc's blog</title><meta name="description" content="Android Layout绘制"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/avatar.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/avatar_rounded.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/gaobing1230" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/vincgao" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Android Layout绘制</h1><div class="post-info">Feb 21, 2016</div><div class="post-content"><blockquote>
<p>最近对View进行了一番研究，主要参考了一下几篇blog，多数为汇总而来，之后不定期删改文章，加深理解，算是我对Android View的一些笔记吧</p>
</blockquote>
<p>参考链接：</p>
<ul>
<li><a href="http://www.codekk.com/blogs/detail/54cfab086c4761e5001b253f" target="_blank" rel="external">http://www.codekk.com/blogs/detail/54cfab086c4761e5001b253f</a></li>
<li><a href="http://blog.csdn.net/guolin_blog/article/details/16330267" target="_blank" rel="external">http://blog.csdn.net/guolin_blog/article/details/16330267</a></li>
<li><a href="http://blog.csdn.net/singwhatiwanna/article/details/38426471" target="_blank" rel="external">http://blog.csdn.net/singwhatiwanna/article/details/38426471</a></li>
</ul>
<h1 id="View-树的绘图流程"><a href="#View-树的绘图流程" class="headerlink" title="View 树的绘图流程"></a>View 树的绘图流程</h1><p>当 Activity 接收到焦点的时候，它会被请求绘制布局，该请求由 Android framework 处理。绘制是从根节点开始，对布局树进行 measure 和 draw。整个 View 树的绘图流程在ViewRoot.java类的<code>performTraversals()</code>函数展开，该函数所做的工作可简单概况为是否需要重新计算视图大小(measure)、是否需要重新安置视图的位置(layout)、以及是否需要重绘(draw)，流程图如下：<br><img src="http://7xp4nq.com1.z0.glb.clouddn.com/view_mechanism_flow.png" alt=""></p>
<p>每一个视图的绘制过程都必须经历三个最主要的阶段：</p>
<ul>
<li>onMeasure()</li>
<li>onLayout()</li>
<li>onDraw()</li>
</ul>
<p><img src="http://7xp4nq.com1.z0.glb.clouddn.com/android.png" height="600" align="center"></p>
<h1 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h1><ul>
<li>measure最重要的成果是在 view 的 <code>onMeasure()</code> 里通过<code>setMeasuredDimension()</code>将mMeasuredWidth和mMeasuredHeight赋值。此过程后可调用 <code>getMeasureWidth()</code> <code>getMeasureHeight()</code>。</li>
<li>layout过程，得到mLeft、mTop、mBottom、mRight。另外，所有的ViewGroup类都应重写onLayout。</li>
<li>draw对视图进行绘制，拢共分6个步骤。</li>
<li>mMeasuredWidth、mMeasuredHeight、mLeft、mTop、mBottom、mRight均是View类的成员变量。</li>
</ul>
<h1 id="一、onMeasure"><a href="#一、onMeasure" class="headerlink" title="一、onMeasure()"></a>一、onMeasure()</h1><p>从整体上看Measure和Layout两个步骤的执行：<br><img src="http://7xp4nq.com1.z0.glb.clouddn.com/measure_layout.png" alt=""></p>
<p>树的遍历是有序的，由父视图到子视图，每一个ViewGroup负责测绘它所有的子视图，而最底层的View会负责测绘自身。</p>
<h3 id="measure过程做了什么"><a href="#measure过程做了什么" class="headerlink" title="measure过程做了什么"></a>measure过程做了什么</h3><p>measure过程由<code>measure(int, int)</code>方法发起，从上到下有序测量View，在 measure 过程的最后，每个视图存储了自己的尺寸大小和测量规格。</p>
<p>measure 过程会为一个 View 及所有子节点的 mMeasuredWidth 和 mMeasuredHeight 变量赋值，该值可以通过 <code>getMeasuredWidth()</code>和<code>getMeasuredHeight()</code>方法获得。而且这两个值必须在父视图约束范围之内，这样才可以保证所有的父视图都接收所有子视图的测量。如果子视图对于 Measure 得到的大小不满意的时候，父视图会介入并设置测量规则进行第二次 measure。比如，父视图可以先根据未给定的 dimension 去测量每一个子视图，如果最终子视图的未约束尺寸太大或者太小的时候，父视图就会使用一个确切的大小再次对子视图进行 measure。</p>
<h3 id="measure过程传递尺寸的两个类"><a href="#measure过程传递尺寸的两个类" class="headerlink" title="measure过程传递尺寸的两个类"></a>measure过程传递尺寸的两个类</h3><ul>
<li>ViewGroup.LayoutParams （View 自身的布局参数）</li>
<li>MeasureSpecs 类（<strong>父视图对子视图的测量要求</strong>）</li>
</ul>
<p><strong>ViewGroup.LayoutParams</strong><br>这个类我们很常见，就是用来指定视图的高度和宽度等参数。对于每个视图的 height 和 width，有以下选择：</p>
<ul>
<li>具体值</li>
<li>MATCH_PARENT 表示子视图希望和父视图一样大(不包含 padding 值)</li>
<li>WRAP_CONTENT 表示视图为正好能包裹其内容大小(包含 padding 值)</li>
</ul>
<p>ViewGroup 的子类有其对应的 ViewGroup.LayoutParams 的子类。比如 RelativeLayout 拥有的 ViewGroup.LayoutParams 的子类 RelativeLayoutParams。<br>有时我们需要使用 <code>view.getLayoutParams()</code> 方法获取一个视图 LayoutParams，然后进行强转，但由于不知道其具体类型，可能会导致强转错误。其实该方法得到的就是其所在父视图类型的 LayoutParams，比如 View 的父控件为 RelativeLayout，那么得到的 LayoutParams 类型就为 RelativeLayoutParams。</p>
<p><strong>MeasureSpecs</strong><br>测量规格，包含测量要求和尺寸的信息，有三种模式:</p>
<ul>
<li><p>UNSPECIFIED<br>父视图不对子视图有任何约束，它可以达到所期望的任意尺寸。比如 ListView、ScrollView，一般自定义 View 中用不到。</p>
</li>
<li><p>EXACTLY<br>父视图为子视图指定一个确切的尺寸，而且无论子视图期望多大，它都必须在该指定大小的边界内，对应的属性为 <strong>match_parent 或具体值</strong>，比如 100dp，父控件可以通过MeasureSpec.getSize(measureSpec)直接得到子控件的尺寸。</p>
</li>
<li><p>AT_MOST<br>父视图为子视图指定一个最大尺寸。子视图必须确保它自己所有子视图可以适应在该尺寸范围内，对应的属性为 <strong>wrap_content</strong>，这种模式下，父控件无法确定子 View 的尺寸，只能由子控件自己根据需求去计算自己的尺寸，这种模式就是我们自定义视图需要实现测量逻辑的情况。</p>
</li>
</ul>
<p>MeasureSpec 代表一个 32 位 int 值，高 2 位代表 SpecMode，低 30 位代表 SpecSize。<br>MeasureSpec 内部的一些常量的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_SHIFT = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_MASK = <span class="number">0x3</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNSPECIFIED = <span class="number">0</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXACTLY = <span class="number">1</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_MOST = <span class="number">2</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeMeasureSpec</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sUseBrokenMakeMeasureSpec) &#123;</span><br><span class="line">        <span class="keyword">return</span> size + mode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMode</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (measureSpec &amp; MODE_MASK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (measureSpec &amp; ~MODE_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="measure-核心方法"><a href="#measure-核心方法" class="headerlink" title="measure 核心方法"></a>measure 核心方法</h3><ol>
<li><p><code>measure(int widthMeasureSpec, int heightMeasureSpec)</code><br>该方法定义在View.java类中，为 final 类型，不可被复写，但 measure 调用链最终会回调 View/ViewGroup 对象的 <code>onMeasure()</code>方法，因此自定义视图时，只需要复写 <code>onMeasure()</code> 方法即可。</p>
</li>
<li><p><code>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code><br>该方法就是我们自定义视图中实现测量逻辑的方法，该方法的参数是父视图对子视图的 width 和 height 的测量要求。在我们自身的自定义视图中，要做的就是根据该 widthMeasureSpec 和 heightMeasureSpec 计算视图的 width 和 height，不同的模式处理方式不同。</p>
</li>
<li><p><code>setMeasuredDimension()</code><br>测量阶段终极方法，在 <code>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code> 方法中调用，将计算得到的尺寸，传递给该方法，测量阶段即结束。<strong>该方法也是必须要调用的方法，否则会报异常。</strong>在我们在自定义视图的时候，不需要关心系统复杂的 Measure 过程，只需调用<code>setMeasuredDimension()</code>设置根据 MeasureSpec 计算得到的尺寸即可，你可以参考 ViewPagerIndicator 的 onMeasure 方法。</p>
</li>
</ol>
<p>ViewGroup 的 <code>measureChildren（int widthMeasureSpec, int heightMeasureSpec)</code> 方法对复合 View 的 Measure 流程图：<br><img src="http://7xp4nq.com1.z0.glb.clouddn.com/blog/measurechildflow.png" alt=""></p>
<h3 id="getWidth-和getMeasureWidth-的区别"><a href="#getWidth-和getMeasureWidth-的区别" class="headerlink" title="getWidth()和getMeasureWidth()的区别"></a>getWidth()和getMeasureWidth()的区别</h3><ul>
<li><code>getMeasureWidth()</code>方法在<code>measure()</code>过程结束后可以获取到，<code>getWidth()</code>方法要在<code>layout()</code>过程结束后才能获取到</li>
<li><code>getMeasureWidth()</code>方法中的值是通过<code>setMeasuredDimension()</code>方法来进行设置的，而<code>getWidth()</code>方法中的值则是通过视图右边的坐标减去左边的坐标计算出来的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getMeasuredWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> mMeasuredWidth &amp; MEASURED_SIZE_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> mRight - mLeft;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二、onLayout"><a href="#二、onLayout" class="headerlink" title="二、onLayout()"></a>二、onLayout()</h1><h3 id="layout过程做了什么"><a href="#layout过程做了什么" class="headerlink" title="layout过程做了什么"></a>layout过程做了什么</h3><p>首先要明确的是，子视图的具体位置都是相对于父视图而言的。在 layout 过程中，子视图会调用<code>getMeasuredWidth()</code>和<code>getMeasuredHeight()</code>方法获取到 measure 过程得到的 mMeasuredWidth 和 mMeasuredHeight，作为自己的 width 和 height。ViewRoot的<code>performTraversals()</code>方法会在measure结束后继续执行，并调用View的<code>layout()</code>方法来执行此过程，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br></pre></td></tr></table></figure>
<p>然后调用每一个子视图的<code>layout(l, t, r, b)</code>函数，来确定每个子视图在父视图中的位置(mLeft、mTop、mBottom、mRight)。</p>
<p>View中的<code>onLayout()</code>方法是一个空方法，因为<code>onLayout()</code>过程是为了确定视图在布局中所在的位置，而这个操作应该是由布局来完成的，即父视图决定子视图的显示位置。<br>ViewGroup中的<code>onLayout()</code>方法是一个抽象方法。<strong>所有ViewGroup的子类都必须重写这个方法，LinearLayout、RelativeLayout都需要进行重写，然后在内部按照各自的规则对子视图进行布局。</strong></p>
<p>在ViewGroup中<br>无<code>measure()</code> <code>onMeasure()</code> 、<code>draw()</code> <code>onDraw()</code><br>有<code>layout()</code><br><code>onLayout()</code>方法为abstract方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure>
<p>View中有<code>measure()</code> <code>layout()</code>  <code>draw()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">   setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">           getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三、onDraw"><a href="#三、onDraw" class="headerlink" title="三、onDraw()"></a>三、onDraw()</h1><h3 id="draw过程做了什么"><a href="#draw过程做了什么" class="headerlink" title="draw过程做了什么"></a>draw过程做了什么</h3><p>measure和layout的过程都结束后，ViewRoot中的代码会继续执行并创建出一个Canvas对象，然后调用View的<code>draw()</code>方法来执行具体的绘制工作。<code>draw()</code>方法内部的绘制过程总共可以分为六步，其中第二步和第五步在一般情况下很少用到。</p>
<h3 id="与-draw-过程相关的函数"><a href="#与-draw-过程相关的函数" class="headerlink" title="与 draw 过程相关的函数"></a>与 draw 过程相关的函数</h3><ul>
<li><p><code>View.draw(Canvas canvas)</code> 由于 ViewGroup 并没有复写此方法，因此，<strong>所有的视图最终都是调用 View 的 draw 方法进行绘制的</strong>。在自定义的视图中，也不应该复写该方法，而是复写<code>onDraw(Canvas)</code>方法进行绘制，如果自定义的视图确实要复写该方法，那么请先调用 <code>super.draw(canvas)</code>完成系统的绘制，然后再进行自定义的绘制。</p>
</li>
<li><p><code>View.onDraw()</code> View 的<code>onDraw（Canvas）</code>默认是空实现，自定义绘制过程需要复写的方法，绘制自身的内容。</p>
</li>
<li><p><code>dispatchDraw()</code> 发起对子视图的绘制。View 中默认是空实现，ViewGroup 复写了<code>dispatchDraw()</code>来对其子视图进行绘制。该方法我们不用去管，自定义的 ViewGroup 不应该对<code>dispatchDraw()</code>进行复写。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* Draw traversal performs several drawing steps which must be executed</span><br><span class="line">* in the appropriate order:</span><br><span class="line">*</span><br><span class="line">*      1. Draw the background</span><br><span class="line">*      2. If necessary, save the canvas' layers to prepare for fading</span><br><span class="line">*      3. Draw view's content</span><br><span class="line">*      4. Draw children</span><br><span class="line">*      5. If necessary, draw the fading edges and restore layers</span><br><span class="line">*      6. Draw decorations (scrollbars for instance)</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<p>绘制流程图：<br><img src="http://7xp4nq.com1.z0.glb.clouddn.com/draw_method_flow.png" alt=""></p>
<p>不管是Button也好，TextView也好，任何一个视图都是有滚动条的，只是一般情况下我们都没有让它显示出来而已。</p>
<p>View是不会帮我们绘制内容部分的，因此需要每个视图根据想要展示的内容来自行绘制。TextView、ImageView等类都有重写<code>onDraw()</code>，如果需要复写该方法，请记得先调用父类的方法。(类比所有ViewGroup的子类都必须重写<code>onLayout()</code>)，并且在里面执行了相当不少的绘制逻辑。绘制的方式主要是借助Canvas这个类，它会作为参数传入到<code>onDraw()</code>方法中，供给每个视图使用。Canvas这个类的用法非常丰富，基本可以把它当成一块画布，在上面绘制任意的东西。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/02/thinking-in-java-notes/" class="prev">PREV</a><a href="/2016/02/my-first-blog/" class="next">NEXT</a></div><div data-thread-key="2016/02/android-layout/" data-title="Android Layout绘制" data-url="http://vincgao.com/2016/02/android-layout/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"vincgao"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2016 <a href="http://vincgao.com">Vinc Gao</a>, unless otherwise noted.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-73982618-1",'auto');ga('send','pageview');</script></body></html>